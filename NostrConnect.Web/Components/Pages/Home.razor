@page "/"
@using NostrConnect.Web.Services.Identity
@using BlazeJump.Tools.Services.Connections
@using BlazeJump.Tools.Services.Crypto
@using BlazeJump.Tools.Services.Identity
@using BlazeJump.Tools.Models
@using BlazeJump.Tools.Models.NostrConnect
@using BlazeJump.Tools.Builders
@using BlazeJump.Tools.Enums
@using BlazeJump.Tools.Helpers
@using MudBlazor
@inject IRelayManager RelayManager
@inject ICryptoService CryptoService
@inject IWebIdentityService IdentityService
@inject ILoggingService LoggingService
@inject NavigationManager NavigationManager
@implements IDisposable

<PageTitle>NostrConnect - QR Login</PageTitle>


@if (IdentityService.ActiveUserProfile == null)
{
    <MudStack AlignItems="AlignItems.Stretch">
        <MudText Typo="Typo.h4" Class="fw-bold mb-2" Style="color: #0f172a;">Welcome to Desilo</MudText>
        <MudText Typo="Typo.body1" Class="mb-12" Style="color: #64748b; max-width: 300px;">
            Your secure, private gateway to your health records and vitals.
        </MudText>

        <MudButton Variant="Variant.Filled"
                   Color="Color.Primary"
                   Size="Size.Large"
                   StartIcon="@Icons.Material.Filled.Add"
                   OnClick="@(() => NavigationManager.NavigateTo("/profile"))">
            Create New Profile
        </MudButton>
        <MudButton Variant="Variant.Outlined"
                   Color="Color.Default"
                   Size="Size.Large"
                   OnClick="@(() => NavigationManager.NavigateTo("/import-key"))">
            Import Private Key
        </MudButton>

        <MudText Typo="Typo.caption" Class="mt-8" Style="color: #94a3b8;">
            Secured by End-to-End Encryption
        </MudText>
    </MudStack>
}
else
{
}

@code {
    private Dictionary<string, string> _sessionQRCodes = new();
    private Dictionary<string, bool> _sessionPingingState = new();
    private Dictionary<string, bool> _sessionDisconnectingState = new();
    private Dictionary<string, string> _sessionPingMessages = new();
    private Dictionary<string, bool> _sessionPingSuccess = new();
    private Dictionary<string, TaskCompletionSource<string>> _sessionPingCompletionSources = new();
    private List<string> _logs = new();

    protected override async Task OnInitializedAsync()
    {
        IdentityService.NotifySessionStateChanged += OnSessionStatusChanged;
        IdentityService.PingReceived += OnPingReceived;
        _logs = LoggingService.GetLogs();
        LoggingService.LogAdded += OnLogAdded;

        if (!RelayManager.Relays.Contains("wss://relay.damus.io"))
            RelayManager.TryAddUri("wss://relay.damus.io");

        StateHasChanged();
    }

    private async void OnSessionStatusChanged(object? sender, NostrConnectSession session)
    {
        Console.WriteLine($"[QRConnect] Session {session.SessionId} status changed - IsConnected: {session.IsConnected}");
        await InvokeAsync(StateHasChanged);
    }

    private void OnLogAdded(object? sender, string log)
    {
        _logs = LoggingService.GetLogs();
        InvokeAsync(StateHasChanged);
    }

    private void OnPingReceived(object? sender, NostrConnectResponse response)
    {
        Console.WriteLine($"[QRConnect] Pong received for request ID: {response.Id}");

        // Find the session by matching the response ID with pending requests
        foreach (var kvp in _sessionPingCompletionSources)
        {
            var sessionId = kvp.Key;
            var tcs = kvp.Value;

            if (!tcs.Task.IsCompleted)
            {
                tcs.TrySetResult(response.Result ?? "pong");
                Console.WriteLine($"[QRConnect] Completed TaskCompletionSource for session {sessionId}");
                break;
            }
        }

        InvokeAsync(StateHasChanged);
    }

    private async Task CreateSessionForProfile(UserProfile userProfile)
    {
        var connectionUrl = await IdentityService.CreateNewSession();

        var newSession = userProfile.Sessions.LastOrDefault();
        if (newSession != null)
        {
            var qrCodeDataUrl = QRCodeHelpers.GenerateQRCode(connectionUrl);
            _sessionQRCodes[newSession.SessionId] = qrCodeDataUrl;
        }

        StateHasChanged();
    }

    private async Task AddNewUserProfile()
    {
        await IdentityService.CreateUserProfile();

        if (IdentityService.ActiveUserProfile != null)
        {
            await CreateSessionForProfile(IdentityService.ActiveUserProfile);
        }

        StateHasChanged();
    }

    private async Task AddNewSession(UserProfile userProfile)
    {
        var previousActive = IdentityService.ActiveUserProfile;
        IdentityService.ActiveUserProfile = userProfile;

        await CreateSessionForProfile(userProfile);

        if (previousActive != null && previousActive.PublicKey != userProfile.PublicKey)
        {
            IdentityService.ActiveUserProfile = previousActive;
        }

        StateHasChanged();
    }

    private async Task SendPing(NostrConnectSession session)
    {
        _sessionPingingState[session.SessionId] = true;
        _sessionPingMessages[session.SessionId] = string.Empty;
        StateHasChanged();

        try
        {
            Console.WriteLine($"[QRConnect] Sending ping to session {session.SessionId}...");

            var tcs = new TaskCompletionSource<string>();
            _sessionPingCompletionSources[session.SessionId] = tcs;

            await IdentityService.SendPing(session);

            var timeoutTask = Task.Delay(5000);
            var completedTask = await Task.WhenAny(tcs.Task, timeoutTask);

            if (completedTask == timeoutTask)
            {
                _sessionPingSuccess[session.SessionId] = false;
                _sessionPingMessages[session.SessionId] = $"✗ Ping timeout - no response from device";
                Console.WriteLine($"[QRConnect] Ping timeout for session {session.SessionId}");
            }
            else
            {
                var result = await tcs.Task;
                _sessionPingSuccess[session.SessionId] = true;
                _sessionPingMessages[session.SessionId] = $"✓ Pong received: '{result}' at {DateTime.Now:HH:mm:ss}";
                Console.WriteLine($"[QRConnect] Ping successful for session {session.SessionId}: {result}");
            }
        }
        catch (Exception ex)
        {
            _sessionPingSuccess[session.SessionId] = false;
            _sessionPingMessages[session.SessionId] = $"✗ Ping failed: {ex.Message}";
            Console.WriteLine($"[QRConnect] Ping failed for session {session.SessionId}: {ex.Message}");
        }
        finally
        {
            _sessionPingCompletionSources.Remove(session.SessionId);
            _sessionPingingState[session.SessionId] = false;
            StateHasChanged();

            _ = Task.Run(async () =>
            {
                await Task.Delay(5000);
                await InvokeAsync(() =>
                {
                    _sessionPingMessages[session.SessionId] = string.Empty;
                    StateHasChanged();
                });
            });
        }
    }

    private async Task SendDisconnect(NostrConnectSession session)
    {
        _sessionDisconnectingState[session.SessionId] = true;
        StateHasChanged();

        try
        {
            await IdentityService.SendDisconnect(session);
        }
        finally
        {
            _sessionDisconnectingState[session.SessionId] = false;
            StateHasChanged();
        }
    }

    private void ClearLogs()
    {
        LoggingService.Clear();
        _logs.Clear();
        StateHasChanged();
    }

    public void Dispose()
    {
        IdentityService.NotifySessionStateChanged -= OnSessionStatusChanged;
        IdentityService.PingReceived -= OnPingReceived;
        LoggingService.LogAdded -= OnLogAdded;
    }
}
